#!/bin/sh
#
# Copyright (c) 2001-2003 Gregory M. Kurtzer
#
# Copyright (c) 2003-2017, The Regents of the University of California,
# through Lawrence Berkeley National Laboratory (subject to receipt of any
# required approvals from the U.S. Dept. of Energy).  All rights reserved.
#
# Copyright (c) 2017 Benjamin S. Allen

## Example input:
# WWFS="select /dev/sda,mklabel gpt,mkpart primary ext4 0% 20%,mkpart primary linux-swap 20% 50%,mkpart primary ext4 50% 100%,name 1 boot,name 2 swap,name 3 root,mkfs 1 ext4 '-L boot',mkfs 2 '-L swap' swap,mkfs 3 ext4 '-L root',fstab 3 / ext4 defaults 0 0,fstab 1 /boot ext4 defaults 0 0,fstab 2 swap swap defaults 0 0"

# Exit on any non-zero exit code
set -o errexit

# Pipeline's return status is the value of the last (rightmost) command
# to exit with a non-zero status, or zero if all commands exit successfully.
set -o pipefail

[ -f /etc/functions ] && . /etc/functions

# By default mount a tmpfs volumne for root
WWFS=${WWFS:="select tmpfs,fstab "" / tmpfs rw:relatime:mode=555 0 0"}

WWDISKWAIT=${WWDISKWAIT:=5}

wait_for_disk() {
  local DISK="$1"
  local RETRY=0
  if [ -z "${DISK##*/dev/*}" ]; then
    while [ ! -b "${DISK}" ]; do
      if [ "${RETRY}" -lt "${WWDISKWAIT}" ]; then
        if [ "${RETRY}" -eq 0 ]; then
          msg_gray "   * ${DISK} not ready, retrying."
        else
          msg_gray "."
        fi
        RETRY="$((RETRY+1))"
        sleep 1
      else
        wwlogger "Disk: ${DISK} not found!"
        exit 2
      fi
    done
    if [ "${RETRY}" -gt 0 ]; then
      wwsuccess
    fi
  fi
}

run_parted() {
  local SELECT_DISK="${1}"
  local PARTED_CMDS="${2}"
  case $SELECT_DISK in
    /*)
      if [ -n "${PARTED_CMDS}" ]; then
        msg_gray "   * running parted on ${SELECT_DISK}"
        {
          /sbin/parted --align=optimal --script "${SELECT_DISK}" "${PARTED_CMDS}" && wwsuccess 
        } || { 
          wwfailure
          exit 2
        }
      fi
      ;;
    *)
      return
      ;;
  esac
    
}

run_mkfs() {
  local SELECT_DISK="${1}"
  local PARTITION="${2}"
  local TYPE="${3}"
  shift 3
  local OPTS="${*:-}"

  local DEV="${SELECT_DISK}${PARTITION}"

  if [ -x /usr/bin/udevadm ]; then
    /usr/bin/udevadm settle --timeout=15 --exit-if-exists="${DEV}"
  else
    wait_for_disk "${DEV}"
  fi

  msg_gray "   * formatting ${DEV}"

  case $TYPE in
    swap)
      {
        /sbin/mkswap ${OPTS} "${DEV}" >/dev/null 2>&1 && wwsuccess 
      } || {
        wwfailure
        exit 2
      }
    ;;
    ext2)
      {
        /sbin/mkfs.ext2 -q -F ${OPTS} "${DEV}" >/dev/null 2>&1 && wwsuccess
      } || {
        wwfailure
        exit 2
      }
    ;;
    ext3)
      {
        /sbin/mkfs.ext3 -q -F ${OPTS} "${DEV}" >/dev/null 2>&1 && wwsuccess
      } || { 
        wwfailure
        exit 2
      }
    ;;
    ext4)
      {
        /sbin/mkfs.ext4 -q -F ${OPTS} "${DEV}" >/dev/null 2>&1 && wwsuccess
      } || {
        wwfailure
        exit 2
      }
    ;;
    xfs)
      {
        /sbin/mkfs.xfs -q -f ${OPTS} "${DEV}" >/dev/null 2>&1 && wwsuccess
      } || {
        wwfailure
        exit 2
      }
    ;;
    vfat)
      {
        /sbin/mkfs.vfat ${OPTS} "${DEV}" >/dev/null 2>&1 && wwsuccess
      } || { 
        wwfailure
        exit 2
      }
    ;;
    *)
      wwlogger "Unsupported filesystem type in mkfs command: ${TYPE}"
      wwskipped
    ;;
  esac
}

run_mdadm() {
  local LEVEL="${1}"
  local NUMBER="${2}"

  if [ -z "${LEVEL}" ]; then
    wwlogger "No raid level specified"
    exit 2
  fi

  if [ -z "${NUMBER}" ]; then
    wwlogger "No raid number given for raid${LEVEL}"
    exit 2
  fi

  shift 2
  local COUNT=0
  local MDADMOPTS
  local ARG
  local DEVARGS

  for ARG in "${@:-}"; do
    case "${ARG}" in
      -?*)
        MDADMOPTS="${ARG} ${MDADMOPTS}"
      ;;
      *)
        DEVARGS="${ARG} ${DEVARGS}"
        COUNT=$((COUNT+1))
      ;;
    esac
  done

  if [ ${COUNT} -eq 0 ]; then
    wwlogger "No devices specified for raid${LEVEL} on /dev/md${NUMBER}"
    exit 2
  fi

  local MSG="   * creating raid${LEVEL} on /dev/md${NUMBER} for ${DEVARGS}"
  msg_gray "${MSG}"
  local MSG_REPEAT=0

  local DEVICES
  local DEV

  for DEV in ${DEVARGS}; do
    case "${DEV}" in
      missing|-)
        DEVICES="${DEVICES} missing"
      ;;

      *)
        DEV="/dev/${DEV##*/dev/}"
        if [ -x /usr/bin/udevadm ]; then
          /usr/bin/udevadm settle --timeout=15 --exit-if-exists="${DEV}"
        else
          if [ ! -b "${DEV}" ]; then
            wwrunning
            wait_for_disk "${DEV}"
            MSG_REPEAT=1
          fi
        fi
        DEVICES="$DEVICES ${DEV}"
      ;;
    esac
  done

  if [ ${MSG_REPEAT} = 1 ]; then
    msg_gray "${MSG}"
  fi

  {
    # This is ugly but mdadm always asks for confirmation if disks are not empty, so we need /usr/bin/yes
    (/usr/bin/yes || /bin/true) | /sbin/mdadm --create "/dev/md${NUMBER}" -f "--level=${LEVEL}" --raid-devices=${COUNT} ${MDADMOPTS} ${DEVICES} >/dev/null 2>&1 && wwsuccess
  } || {
    wwfailure
    exit 2
  }
}

update_fstab_and_mount() {
  local SELECT_DISK="${1}"
  local ENTRY="${2}"
  local NEWROOT="${3}"

  if [ "${ENTRY:0:5}" != "UUID=" ] && [ "${ENTRY:0:6}" != "LABEL=" ]; then
    ENTRY="${SELECT_DISK}${ENTRY}"
  fi

  # Add entry to fstab that will be moved into the NEWROOT chroot, transform options field ":" delim to commas
  echo "${ENTRY}" | /usr/bin/awk '{ gsub(/:/,",",$4); print }' >> "${TEMPDIR}/fstab"

  MOUNTPOINT=$(echo "${ENTRY}" | /usr/bin/awk '{ print $2 }')
  msg_gray "   * mounting ${MOUNTPOINT}"
  if [ "${MOUNTPOINT:0:1}" = "/" ]; then
    # Prepend NEWROOT to mount points, transform options field ":" delim to fstab format with commas
    echo "${ENTRY}" | /usr/bin/awk -v NEWROOT="${NEWROOT}" '{ $2 = NEWROOT $2; gsub(/:/,",",$4); print }' >> /etc/fstab
    {
      mkdir -p "${NEWROOT}${MOUNTPOINT}" && \
      mount "${NEWROOT}${MOUNTPOINT}" && wwsuccess
    } || {
      wwfailure
      exit 2
    }
  else 
    wwskipped
  fi
}

{
  SELECT_DISK=""
  PARTED_CMDS=""
  FIRST_DISK=1
  NEWROOT=${NEWROOT:=/newroot}
  TEMPDIR=${TEMPDIR:=/tmp}
  WWSELECTDISKWAIT=${WWSELECTDISKWAIT:=5}

  IFS=","

  # Status for parent filesystem message
  wwrunning

  if [ ! -e /etc/mtab ]; then
    ln -s /proc/mounts /etc/mtab
  fi

  for FSCMD in ${WWFS}; do
    case ${FSCMD} in

    # Don't pass select commands directly to parted as parted --script 
    # needs a device specified on the CLI
    select*)
      if [ "${FIRST_DISK}" -eq 1 ]; then
        FIRST_DISK=0
      else
        # Run any accumulated parted commands before changing selected disk
        run_parted "${SELECT_DISK}" "${PARTED_CMDS}"
        PARTED_CMDS=""
        SELECT_DISK=""
      fi
      SELECT_DISK=$(echo "${FSCMD}" | cut -f 2 -d' ')
      if [ "${SELECT_DISK}" != "/dev/md" ]; then
        wait_for_disk "${SELECT_DISK}"
      fi
    ;;

    fstab*)
      if [ -z "${SELECT_DISK}" ]; then
        wwlogger "No select disk set before fstab command: ${FSCMD:6}"
        exit 2
      fi
      # Run any accumulated parted commands before continuing with fstab
      run_parted "${SELECT_DISK}" "${PARTED_CMDS}"
      PARTED_CMDS=""
      update_fstab_and_mount "${SELECT_DISK}" "${FSCMD:6}" "${NEWROOT}"
    ;;

    mkfs*)
      if  [ -z "${SELECT_DISK}" ]; then
        wwlogger "No select disk set before mkfs command: ${FSCMD:5}"
        exit 2
      fi

      # Run any accumulated parted commands before continuing with mkfs
      run_parted "${SELECT_DISK}" "${PARTED_CMDS}"
      PARTED_CMDS=""

      # Need FSCMD to be split into individual arguments for run_mkfs
      unset IFS
      run_mkfs "${SELECT_DISK}" ${FSCMD:5}
      IFS=","
    ;;

    raid0*|raid1*|raid4*|raid5*|raid6*)
      # Run any accumulated parted commands before continuing with raid
      run_parted "${SELECT_DISK}" "${PARTED_CMDS}"
      PARTED_CMDS=""

      # Need FSCMD to be split into individual arguments for run_mdadm
      unset IFS
      run_mdadm ${FSCMD:4}
      IFS=","

      # Now select /dev/md for filesystem creation
      SELECT_DISK=/dev/md
    ;;

    # All parted command except select
    align-check*|help*|mklabel*|mktable*|mkpart*|name*|print*|quit|rescue*|rm*|disk_set*|disk_toggle*|set*|toggle*|unit*|version)
      if [ -z "${SELECT_DISK}" ]; then
        wwlogger "No selected disk set before command: ${FSCMD}"
        exit 2
      fi

      if [ -z $PARTED_CMDS ]; then
        PARTED_CMDS="${FSCMD}"
      else
        PARTED_CMDS="${PARTED_CMDS} ${FSCMD}"
      fi
    ;;

    *)
      wwlogger "Unknown parted command: ${FSCMD}"
      exit 2
    ;;
    esac

  done
  msg_white " * filesystems"  
}
